package com.bluntsoftware.ludwig.conduit.activities.ai;

import com.bluntsoftware.ludwig.conduit.activities.TypedActivity;
import com.bluntsoftware.ludwig.conduit.activities.ai.domain.AITextRequest;
import com.bluntsoftware.ludwig.conduit.activities.ai.domain.AITextResponse;
import com.bluntsoftware.ludwig.conduit.config.ai.domain.OpenAiConfig;
import com.bluntsoftware.ludwig.conduit.service.ai.AIService;
import com.bluntsoftware.ludwig.conduit.service.ai.domain.AICompletionRequest;
import com.bluntsoftware.ludwig.conduit.service.ai.domain.AICompletionResponse;
import com.bluntsoftware.ludwig.conduit.service.ai.domain.AIMessage;
import com.bluntsoftware.ludwig.conduit.service.ai.domain.OpenAiModel;
import com.bluntsoftware.ludwig.domain.Knowledge;
import com.bluntsoftware.ludwig.domain.KnowledgeBase;
import com.bluntsoftware.ludwig.domain.KnowledgeChunk;
import com.bluntsoftware.ludwig.repository.ActivityConfigRepository;
import com.bluntsoftware.ludwig.repository.KnowledgeBaseRepository;
import com.bluntsoftware.ludwig.repository.impl.KnowledgeChunkCustomRepositoryImpl;
import com.bluntsoftware.ludwig.service.KnowledgeService;
import com.bluntsoftware.ludwig.tenant.TenantResolver;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

/**
 * OpenAITextActivity is a service class extending TypedActivity, used to handle AI-driven
 * text processing workflows. It leverages OpenAI's GPT model to generate responses based
 * on user queries, instructions, and knowledge base data.
 *
 * This class is responsible for integrating and interacting with external AI services,
 * performing operations on data from user-provided and system knowledge bases, and managing
 * classified user inputs.
 *
 * Key features include:
 * - Handling AITextRequest and AITextResponse as input and output models.
 * - Interfacing with OpenAI's GPT API for generating responses.
 * - Engaging with knowledge base repositories to retrieve or save relevant data.
 * - Classifying user inputs into specific categories (e.g., Question, Statement, Command).
 *
 * Core Methods:
 * - run: Executes the primary activity workflow. It processes AITextRequest input, generates AI responses,
 *   performs classification, and optionally saves user or knowledge base data.
 * - searchSystemKnowledgeBase: Retrieves relevant information from the system knowledge base
 *   using query vectors generated by the AI service.
 * - searchUserKnowledgeBase: Retrieves the user's conversation history from the knowledge base.
 * - searchKnowledgeBase: Performs a generic search on a specified knowledge base and fetches similar knowledge chunks.
 * - classifyInput: Utilizes AI services to classify textual input into a predefined category.
 *
 * Dependencies:
 * - KnowledgeChunkCustomRepositoryImpl: Custom repository for querying knowledge chunks.
 * - KnowledgeService: Service for managing and interacting with knowledge data.
 * - KnowledgeBaseRepository: Repository for accessing knowledge base metadata.
 * - AIService: External service used for OpenAI configuration, embeddings, and AI completions.
 * - ActivityConfigRepository: Repository providing configuration for activity behavior.
 *
 */
@Slf4j
@Service
public class OpenAITextActivity extends TypedActivity<AITextRequest, AITextResponse> {

    private final KnowledgeChunkCustomRepositoryImpl knowledgeChunkCustomRepository;
    private final KnowledgeService knowledgeService;
    private final KnowledgeBaseRepository knowledgeBaseRepository;

    public OpenAITextActivity(ActivityConfigRepository activityConfigRepository, KnowledgeChunkCustomRepositoryImpl knowledgeChunkCustomRepository, KnowledgeService knowledgeService, KnowledgeBaseRepository knowledgeBaseRepository) {
        super(activityConfigRepository,AITextRequest.class);
        this.knowledgeChunkCustomRepository = knowledgeChunkCustomRepository;
        this.knowledgeService = knowledgeService;
        this.knowledgeBaseRepository = knowledgeBaseRepository;
    }

    @Override
    public AITextRequest input() {
        return AITextRequest.builder().build();
    }

    @Override
    public AITextResponse output() {
        return AITextResponse.builder().build();
    }

    @Override
    public AITextResponse run(AITextRequest aiText) throws Exception {
        OpenAiConfig openAiConfig  = getExternalConfigByName(aiText.getConfig(), OpenAiConfig.class);
        KnowledgeBase kb = knowledgeBaseRepository.findAllByName(aiText.getKnowledgeBase()).blockFirst();
        String textOut = "No Ai Response";
        String classification = null;
        if(openAiConfig != null && openAiConfig.getSecret() != null){
            AIService aiService = new AIService( openAiConfig.getSecret() );
            log.info("Running open AI Text Activity Current Tenant is {}" , TenantResolver.resolve());

            List<AIMessage> messages = new ArrayList<>();

            //Search the user the Knowledge base
            if(aiText.getUser() != null && !aiText.getUser().isEmpty()){
                messages.add(searchUserKnowledgeBase(aiText,kb));
            }
            //Search the system Knowledge base
            if(aiText.getKnowledgeBase() != null && !aiText.getKnowledgeBase().isEmpty()){
                messages.add(searchSystemKnowledgeBase(aiText, aiService.getEmbedding(aiText.getText())));
            }
            //Get Ai Bot instructions
            if(aiText.getInstructions() != null && !aiText.getInstructions().isEmpty()){
                messages.add(AIMessage.builder().role("system").content(aiText.getInstructions()).build());
            }

            AIMessage userMessage = AIMessage.builder()
                    .role("user")
                    .content(aiText.getText())
                    .build();
            messages.add(userMessage);

            AICompletionRequest request =  AICompletionRequest.builder()
                    .messages(messages)
                    .max_tokens(openAiConfig.getMax_tokens())
                    .store(openAiConfig.isStore())
                    .temperature(openAiConfig.getTemperature())
                    .model(openAiConfig.getModel())
                    .build();

            AICompletionResponse response = aiService.completions(request);

            if(response != null && response.getChoices() != null && !response.getChoices().isEmpty()){
                textOut = response.getChoices().get(0).getMessage().getContent();
            }

            classification = classifyInput(openAiConfig, aiText.getText());
        }

        //Save
        if(classification!= null && classification.equalsIgnoreCase("Statement") &&
                kb != null && aiText.getUser() != null && !aiText.getUser().isEmpty()){
            Knowledge knowledge = knowledgeService.findAllByBaseIdAndUserId(kb.getId(),aiText.getUser()).block();
            String id = knowledge == null ? UUID.randomUUID().toString() : knowledge.getId();
            String text = aiText.getText() + "\r\n";
            text = knowledge == null ? text : text + knowledge.getText() ;

            knowledgeService.save(Knowledge.builder()
                            .id(id)
                            .baseId(kb.getId())
                            .text(text)
                            .userId(aiText.getUser())
                            .description("user conversation for " + aiText.getUser())
                            .build())
                    .block();
        }

        //Default Values
        return AITextResponse.builder()
                .text(textOut)
                .build();
    }

    private AIMessage searchSystemKnowledgeBase(AITextRequest aiTextRequest, List<Double> queryVector) {
        return searchKnowledgeBase("system",aiTextRequest.getKnowledgeBase(),queryVector);
    }

    public AIMessage searchUserKnowledgeBase(AITextRequest aiTextRequest,KnowledgeBase kb){

        Knowledge knowledge = knowledgeService.findAllByBaseIdAndUserId(kb.getId(),aiTextRequest.getUser()).block();
        String userStatements = "";
        if(knowledge != null && knowledge.getText() != null && !knowledge.getText().isEmpty()){
            userStatements = knowledge.getText();
        }

        return AIMessage.builder()
                .role("system")
                .content(userStatements)
                .build();
    }

    public AIMessage searchKnowledgeBase(String user,String knowledgeBase, List<Double> queryVector){

        List<KnowledgeChunk> knowledgeChunks =  knowledgeChunkCustomRepository
                .findSimilarChunks(user,knowledgeBase,queryVector,50)
                .collectList()
                .block();

        StringBuilder combinedText = new StringBuilder();

        if (knowledgeChunks != null) {
            knowledgeChunks.forEach(kc -> {
                String text = kc.getText();
                if (text != null) {
                    combinedText.append(text).append(System.lineSeparator());
                }
            });
        }

        return AIMessage.builder()
                .role("system")
                .content(combinedText.toString())
                .build();
    }

    //Question, Statement or Command
    String classifyInput(OpenAiConfig openAiConfig,String text) {
        AIService aiService = new AIService( openAiConfig.getSecret() );
        String prompt = "Classify the following input as 'Question', 'Statement', or 'Command':\n\n" + text + "\n\n";

        AIMessage systemMessage = AIMessage.builder()
                .role("system")
                .content("You are a classifier that determines if an input is a Question, Statement, or Command.")
                .build();

        AIMessage userMessage = AIMessage.builder()
                .role("user")
                .content(prompt)
                .build();

        AICompletionResponse response = aiService.completions(AICompletionRequest.builder()
                        .message(systemMessage)
                        .message(userMessage)
                        .max_tokens(100)
                        .store(false)
                        .temperature(openAiConfig.getTemperature())
                        .model(OpenAiModel.GPT_4_TURBO.getValue())
                        .build());

        String textOut = "Question";
        if(response != null && response.getChoices() != null && !response.getChoices().isEmpty()){
            textOut = response.getChoices().get(0).getMessage().getContent();
        }
        return textOut;
    }


}
